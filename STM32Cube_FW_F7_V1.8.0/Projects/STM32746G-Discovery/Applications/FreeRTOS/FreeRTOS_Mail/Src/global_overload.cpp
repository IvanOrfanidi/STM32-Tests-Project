/**
 * @file global_overload.cpp
 * @brief Глобальная перегрузка операторов new и delete
 */

#include "FreeRTOS.h"

/*
Господа, позвольте представить Вашему вниманию три куска простого кода:

Object *object = new Object;
delete object;

или

Object *object = new Object(1, 2, 3);
delete object;

или

Object *object = new Object[5];
delete[] object;
.

Давайте разбеемся, что тут происходит на самом деле.

Когда компилятор языка C++ встречает в коде такое выражение как: new Object;
то вместо него он генерирует соответствующий ассемлерный код. Если его попытаться представить
с помощью языка С++, то получится примерно следующее:

Object *object = operator new (sizeof(ObjectType)); // Выделить память размером sizeof(ObjectType)
if (object != NULL)
{
   object->Object(); // При успешном выделении памяти вызвать соответствующий конструктор объекта
}

Код делает следующее:
вызывает одноименную функцию operator new (size_t) встроенного в C++ менеджера памяти,
чтобы выделить память из кучи под создаваемый объект. И если удалось выделить память,
то вызывает конструктор объекта.

Соответственно, встретив в коде выражение: new Object(1, 2, 3),
будет сгенерирован примерно следующий код:

Object *object = operator new (sizeof(ObjectType)); // Выделить память размером sizeof(ObjectType)
if (object != NULL)
{
   object->Object(1, 2, 3); // При успешном выделении памяти вызвать соответствующий конструктор объекта
}

Т.е. попытается выделить память под объект класса Object и в случае успеха вызовет соответствющий
конструктор создаваемого объкта.

Если встретит такое выражение: new Object[5];, то сгенерирует следующй код:
   
Object *object = operator new (sizeof(Object) * 5); // Выделить память размером sizeof(ObjectType) * 5
if (object != NULL)
{
   for(uint32_t i=0; i<5; i++) // При успешном выделении памяти вызвать соответствующий конструктор
      object[i]->Object();    // для каждого из пяти создаваемый объектов
}
   
Т.е. попытается выделить память под пять объектов класса Object и в
случае успеха вызовет для каждого объекта конструктор.


Также дела обстаят и с выражением delete.
Когда компилятор языка C++ встречает в коде такое выражение как delete object,
где object - указатель на объект класса Object,
то вместо него он генерирует соответствующий ассемлерный код. Если его попытаться представить
с помощью языка С++, то получится примерно следующее:

object->~object();  // Вызвать деструктор удаляемого объекта
operator delete (object); // высвоободить память из-под удаляемого объекта


Код делает следующее:
вызывает одноименную функцию operator delete (void *) встроенного в C++ менеджера памяти,
чтобы высвободить память из кучи из-под удаляемого объекта. И
вызывает деструктор объекта.

Если встретит такое выражение delete []Object; , то сгенерирует примерно следующй код:

for(uint32_t i=0; i<5; i++)  // Вызвать деструктор для каждого из пяти объектов
   object[i]->~Object();
operator delete (object);    // высвоободить память из-под пяти удаляемых объектов

Т.е. вызывает одноименную функцию operator delete (void *) встроенного менеджера памяти,
чтобы высвободить память из кучи из-под пяти созданных объектов. И
вызывает деструкторы для каждого из пяти объекта.


Функции void *operator new (size_t size) и void operator delete (void *p) можно перегрузить,
чтобы например использовать свой менеджер памяти.

Собственно так и сделаем, т.к. мы используем операционную систему
и встроенные в C++ функции работы с памятью не потоко-безопасны!
Поэтому будем использовать потоко-безопасные функции менеджера памяти, предоставляемого самой ОС.
*/

void* operator new(size_t size)
{
   return pvPortMalloc(size);
}

void operator delete(void* p)
{
   vPortFree(p);
}
/*
Это называется глобальная перегрузка функцй new и delete.
Так же их можно перегрузить локально для каких-нибудь классов. Но это пока лишнее и делать не будем.
*/
